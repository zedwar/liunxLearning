#环境变量的含义
        PATH 

 init init 命令进程和作业管理 init 命令是 Linux 下的进程初始化工具， init 进程是所有 Linux 进程的父进程，它的进程号为 1 。 init 命令是 Linux 操作系统中不可缺少的程序之一， init 进程是 Linux 内核引导运行的，是系统中的第一个进程。
cut ：从文本文件的每一行中截取指定内容的数据。
cp ：用来复制文件或目录。
dd ：将指定的输入文件拷贝到输出文件中，在拷贝的过程中可以进行格式转换。
fmt ：将所有非空白行的长度设置为几乎相同，来进行简单的文本格式化。
（ 1 ） ps [options] [--help]    显示瞬间行程 (process) 的动态
     -A    列出所有的进程
     -w    显示加宽可以显示较多的资讯
     -au    显示较详细的资讯
     -aux    显示所有包含其他使用者的行程
（ 2 ） Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics) ， masquerade 连接，多播成员 (Multicast Memberships) 等等。
（ 3 ） df [ 选项 ] [ 文件 ] 显示指定磁盘文件的可用空间。如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示
（4） ifconfig [ 网络设备 ] [ 参数 ]    用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置
route：route 命令是在本地IP路由表中显示和修改条目网络命令；
tracert:跟踪路由，是路由跟踪的实用程序，用于确定IP数据包访问目标所采取的路径；
/etc/resolv.conf文件功能：DNS客户机配置文件，设置DNS服务器的IP地址及DNS域名
/etc/host.conf 指定主机名查找方法，通常指先查找文件/etc/hosts,找不到时再向DNS服务器请求。
/etc/networks配置网络的
Linux crontab中* * * * * /usr/local/run.sh分食日月粥
孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。
如果进程不调用wait / waitpid的话，  那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。
孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上 ，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和***出面处理它的一切善后工作。 因此孤儿进程并不会有什么危害。
有时会刻意使进程成为孤儿。比如 守护进程daemon，nohup命令
-r递归删除
-f强制删除，因为是非空目录，不加f会删除不了的
s表示替换命令， /AAA 表示匹配AAA， /BBB 表示把匹配替换成BBB，/g 表示一行上的替换所有的匹配） xyz 表示替换xyz文件中的xyz
 g 表示行内全面替换。 
p 表示打印行。 
w 表示把行写入一个文件。
 x 表示互换模板块中的文本和缓冲区中的文本。
 y 表示把一个字符翻译为另外的字符（但是不用于正则表达式）
 \1 子串匹配标记 
& 已匹配字符串标记 
Linux系统下，一切都是文件，硬件设备也是文件
对目录来说只有（r）权限是无法进入的，还要赋予执行权限（x）
一般删除都是文件索引，如果两个文件同时打开同一个文件，一个线程执行删除操作，只要另一个线程不退出，就可以继续对该文件进行操作，一旦退出才找不到该文件的索引节点而报错。
UNIX系统由内核、shell、文件系统和应用程序等4部分组成。
cat：由第一行开始显示文件所有内容；
tac：从最后一行开始显示文件的所有内容，注意 tac 与cat 写法正好相反；
more：一页一页的显示文件内容，只能向后翻页；
less：也是一页一页显示文件内容，但是可以通过键盘上的【pagedown】，【pageup】控制向后，向前翻页；
head：显示一个文件的前几行；
tail：显示一个文件的后几行；
将几个文件合并为一个文件： $cat file1 file2 
-n 或 --number 由 1 开始对所有输出的行数编号
上述命令即将file1和file2的文件内容连在一起然后输出到屏幕，并打印行号，file1和file2文件内容不变 
ndd： 删除当前行开始的连续 n 行。
dd：删除 光 标所在行，
n1,n2d： 删除n1到n2行，例如删除1到10行1,10d
n，$d：删除从某行开始至文本末尾，例如删除第8行至末尾 8,$d
l表示link
d表示directory
~/.bash_profile:每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件. 此文件类似于/etc/profile，也是需要需要重启才会生效，/etc/profile对所有用户生效，~/.bash_profile只对当前用户生效。 ~/.bashrc:该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.（每个用户都有一个.bashrc文件，在用户目录下） 此文件类似于/etc/bashrc，不需要重启生效，重新打开一个bash即可生效， /etc/bashrc对所有用户新打开的bash都生效，但~/.bashrc只对当前用户新打开的bash生效。
kill pid让进程正常退出
kill %job number 直接杀掉进程
scp用于远程数据传输
ssh用于远程登录
uptime命令可以查看当前linux系统运行了多长时间
/home/用户名/.bash_history或者是/root/.bash_history,.bash_history文件应该是在用户家目录下的。
同上，.bash_profile文件也是放在家目录的，可以理解为该用户登录时自动运行的脚本。
/var/log/messages 旨在存储有价值的。非调试的和非关键的消息。 这里日志应被视为"常规系统活动"日志。
/var/log/syslog 依次记录所有内容，除身份验证相关消息。
export用于将shell变量输出为环境变量，或者将shell函数输出为环境变量
cat经常用来显示文件的内容
echo用于在shell中打印shell变量的值，或者直接输出指定的字符串
env用于显示系统中已存在的环境变量，以及在定义的环境中执行指令
/etc/fstab是用来存放文件系统的静态信息的文件。位于/etc/目录下，可以用命令less /etc/fstab 来查看，如果要修改的话，则用命令 vi /etc/fstab 来修改。
       当系统启动的时候，系统会自动地从这个文件读取信息，并且会自动将此文件中指定的文件系统挂载到指定的目录。下面我来介绍如何在此文件下填写信息。
stack由系统自动分配，heap需要程序员自己申请，C中用函数malloc分配空间，用free释放，C++用new分配，用delete释放。
当然热爱java的童鞋肯定更关心java的内存空间划分（虽然强大的java让程序猿在编程时不需要考虑太多内存方面的细节）
java 对内存空间的划分五部分
oute print--本命令用于显示路由表中的当前项目，由于用IP地址配置了网卡，因此所有的这些项目都是自动添加的。
route add--使用本命令，可以将新路由项目添加给路由表。例如，如果要设定一个到目的网络209.98.32.33的路由，其间要经过5个路由器网段，首先要经过本地网络上的一个路由器，其IP为202.96.123.5，子网掩码为255.255.255.224，那么你应该输入以下命令：
route add 209.98.32.33 mask 255.255.255.224 202.96.123.5 metric 5
route change--你可以使用本命令来修改数据的传输路由，不过，你不能使用本命令来改变数据的目的地。下面这个例子可以将数据的路由改到另一个路由器，它采用一条包含3个网段的更直的路径：
route change 209.98.32.33 mask 255.255.255.224 202.96.123.250 metric 3
route delete--使用本命令可以从路由表中删除路由。例如：route delete 209.98.32.33
route命令主要用于手动配置静态路由表
malloc/free和new/delete的本质区别：
1.malloc/free 是C/C++语言的标准库函数，new/delete是C++的运算符
2.new 能自动分配空间大小
3.对于用户自定义的对象而言，用malloc/free无法满足动态管理对象的要求
    对象在创建的时候会自动调用构造函数，对象在消亡之前自动执行析构函数
    由于malloc/free是库函数而不是运算符，不在编译器的控制范围，不能把构
    造函数和析构函数的任务强加于malloc/free 。一次C++需要一个能够对对象完
    成动态分配内存和初始化工作的运算符new，以及一个释放内存的运算符
    delete。简单来说就是new/delete能完成跟家详细的对内存的操作，而malloc/
    free不能。
linux下，这些四个命令或者工具，都在特定目录下对应有相应的可执行程序，终端下输入的参数，对应的是源码中函数的参数，所以工具或者命令，它们的都是可执行程序。
telnet为用户提供了在本地计算机上完成远程主机工作的能力,使用Telnet协议，是TCP/IP 协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。；
wget 是一个从网络上自动下载文件的自由工具，支持通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP***。
scp是有Security的文件copy，可以把当前一个文件copy到远程另外一台主机上，基于SSH登录,SSH采用面向连接的TCP协议传输 ，应用22号端口 安全系数较高。
rsync是类unix系统下的数据镜像备份工具——remote sync。支持本地复制，或者与其他SSH、rsync主机同步。可以使用scp、ssh等方式来传输文件，当然也可以通过直接的socket连接。
个人认为，rsync支持的协议更多，可以是面向连接的（tcp协议），也可以是无连接的（udp协议，socket中可以选择），然而上面三个采用的都是面向连接的协议（Telnet，TCP，HTTP, SSH等），一定程度上保证可靠性。
可以 继续执行 的方式有（）这题问的已经很明显了。答案A肯定不对啊。
ctrl  z 就是挂起一个进程，暂停的意思
fg是将进程放到前台并唤醒
bg是将进程放到后台并唤醒
ctrl+h,在shell就是向左删除的作用
标识一个TCP连接的是，客户端和服务器的IP地址加端口号，尽管服务器IP地址和端口号一样，但是客户端IP地址是不一样的，而客户端端口号只有本地意义，所以理论上服务器一个端口号能接受的TCP连接是无上限的。
pthread_join()函数等待线程指定的线程 
终止。 如果线程已经终止,那么pthread_join() 
立即返回。 指定的线程必须可接合线程。 
如果retval不是NULL,那么pthread_join()退出状态的副本 
目标线程(即。 目标线程提供的价值 
pthread_exit(3))* retval所指向的位置。 如果沥青量 
线程被取消了,那么PTHREAD_CANCELED放在* retval。 
ps   查看当前系统中的进程
who -b   查看当前系统的启动时间
last reboot   查看当前系统的启动时间
w    查看当前系统的启动时间
top   查看当前系统的启动时间
uptime    查看当前系统的启动时间
Binwalk是用于搜索给定二进制镜像文件以获取嵌入的文件和代码的工具。
Linux file命令用于辨识文件类型。
firmware-mod-kit工具的功能和binwalk工具的类似
Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。
fopen是ANSIC标准中的C语言库函数，在不同的系统中应该调用不同的内核api
linux中的系统函数是open，fopen是其封装函数，
vsftpd 是“very secure FTP daemon”的缩写，安全性是它的一个最大的特点。vsftpd 是一个 UNIX 类操作系统上运行的服务器的名字，它可以运行在诸如 Linux、BSD、Solaris、 HP-UNIX等系统上面，是一个完全免费的、开放源代码的ftp服务器软件，支持很多其他的 FTP 服务器所不支持的特征。比如：非常高的安全性需求、带宽限制、良好的可伸缩性、可创建虚拟用户、支持IPv6、速率高等。
anon_max_rate:匿名访问最大传输速率，anon是anonymous(匿名的)的缩写
/proc/interrupts 显示使用的中断
 /proc/ioports 当前使用的I/O端口
 /proc/kcore 系统物理内存映像。与物理内存大小完全一样，但不实际占用这么多的内存。
 /proc/kmsg  内核输出的消息，也被送到syslog
su是在用户间切换，可以是从普通用户切换到root用户，也可以是从root用户切换到普通用户。如果当前是root用户，那么切换成普通用户test用以下命令： 
su - test 
如果要切换回root用户，那么用以下命令： 
su或su - 
用户名root可以省略不写。 
切换回root用户时要输入root密码。一般直接输入exit命令来切换回root用户，这样就不用输入密码。
A du(disk usage) 命令功能说明：统计目录(或文件)所占磁盘空间的大小
B df(disk file) 命令功能说明： 用于显示文件系统的磁盘使用情况
C free 命令功能说明： 可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区
D vmstat 命令功能说明： 命令报告关于内核线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息
 $0   #  脚本启动名(包括路径)
 $n   #  第n个参数,n=1,2,…9
 $*   #  所有参数列表(不包括脚本本身)
 $@   #  所有参数列表(独立字符串)
 $#   #  参数个数(不包括脚本本身)
 $$   #  当前程式的PID
 $!   #  执行上一个指令的PID
 $?   #  执行上一个指令的返回值
-u 用户号 指定用户的用户号；因为系统用户的用户号为0，故指定用户号为0 如果同时有-o选项，则可以重复使用其他用户的标识号；因为系统本身存在用户号为0的系统用户，故应该使用该参数
etc/rc.d/rc.local：一个启动加载配置文件，这个配置文件会在用户登陆之前读取，这个文件中写入了什么命令，在每次系统启动时都会执行一次。也就是说，如果有任何需要在系统启动时运行的工作，则只需写入 /etc/rc.d/rc.local 配置文件即可。把一个程序加入开机启动，一般也可以通过修改rc.local来完成。
>和>>：他们俩其实唯一的区别就是>是重定向到一个文件，>>是追加内容到文件。两个命令都是如果文件不存在则创建文件。
1>>、2>>、1>、2>：1表示运行程序时程序正确运行输出结果的重定向、1表示运行程序时时程序错误运行信息（如异常信息）的重定向，然后>>与>的区别和上面一样。
注：echo "mkdir /misc/`date +%Y%m%d`" >> /etc/rc.d/rc.local不一定在实际操作中有用，应为rc.local会被Linux的不同版本修改，如ubuntu中在case语句块里脚本就退出了，追加到文件尾部的话不会被执行。
Ctrl+C： 终止并退出前台命令的执行，回到SHELL。 Ctrl+Z： 暂停前台命令的执行，将该进程放入后台，回到SHELL。 jobs： 查看当前在后台执行的命令，可查看命令进程号码。 &： 运行命令时，在命令末尾加上&可让命令在后台执行
题目的意思是什么参数一般用于CD-ROM等移动设备
参数 default表示和使用默认设置
        sw 表示自动挂载的可读写分区
        ro 表示挂载只读权限的
        rw 表示挂载读写权限的
所以选择D。表示手动挂载的，也用于CD-ROW等移动设备
lseek()函数：移动文件的读写位置
read() write()读写文件
pread() pwrite()带偏移量的读写文件
都属于系统调用
feek() 库函数
kill杀死前台和后台的进程，而ctrl+c只能杀死正在运行的进程也就是前台进程
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；
线程是进程的一个实体，一个进程中包含多个线程。是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位
B进程有独立的地址空间，线程没有。线程是共享进程的地址空间，因此B错误
D进程是 操作系统进行资源分配和调度的一个独立单位，而线程只是CPU调度和分派的基本单位，因此D错误
cat 在没有指定文件的时候，其功能是将标准输入定向至标准输出。
所以E答案中。管道前一部分的`cat file1`，会将cat1内容输出至【标准输出】，经过管道成为下一个cat的【标准输入】，同时 > 会将内容重定向值file2，是为复制了。
ifconfig是查看eth0的IP地址，其它都是分配IP地址
运行态 (Running) ：              占有CPU，并在CPU上运行
就绪态 (Ready)：                  已经具备运行条件，但由于没有空闲CPU，而暂时不能运行
等待态 (Waiting/Blocked)：   因等待某一事件而暂时不能运行：如等待读盘结果
whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。whereis 程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。
Maxfd是三个套接字描述符中最大数字加上1
dpkg  ---- deb
yum   -----rpm
apt-get --- deb
tar ----- bz2
unzip ------ zip
h host
u user
p password
cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl。
如果是采用证书认证的http地址，证书在本地，那么curl这样使用： 
curl -E mycert.pem https://that.secure.server. com
bin 存放普通用户可以使用的指令。
/usr 这个目录中包含了命令库文件和在通常操作中不会修改的文件，其地位类似Windows上面的”Program Files”目录（安装程序的时候，默认就是安装在此文件内部某个子文件夹内。输入命令后系统默认执行/usr/bin下的程序。
/etc 全局的配置文件存放目录。存放系统和软件的配置。
/boot 引导程序，内核等存放的目录。
fork()是全部复制
vfork()是共享内存
clone()是可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的clone_flags来决定。另外，clone()返回的是子进程的pid。
:s/old/new 将当前行中查找到的第一个字符“old” 串替换为“new”
:s/old/new/g 将当前行中查找到的所有字符串“old” 替换为“new”
:#,#s/old/new/g 在行号“#,#”范围内替换所有的字符串“old”为“new”
:%s/old/new/g 在整个文件范围内替换所有的字符串“old”为“new”
:s/old/new/c 在替换命令末尾加入c命令，将对每个替换动作提示用户进行确认
用于进程间通讯(IPC)的四种不同技术: 
1. 消息传递(管道,FIFO,posix和system v消息队列) 
2. 同步(互斥锁,条件变量,读写锁,文件和记录锁,Posix和System V信号灯) 
3. 共享内存区(匿名共享内存区,有名Posix共享内存区,有名System V共享内存区)  4. 过程调用(Solaris门,Sun RPC) 
C：命名管道虽然可以通讯，但是把变量的地址传递过去是没有用的，因为不同的进程的地址空间是独立的，谁也不能访问谁的，只有传值才行，传地址是不行的，所以C错；
D：子进程虽然是由父进程fork()出来的，但是仍然属于两个进程，不同进程之间也是独立的，子进程无权读取父进程的变量。
使用useradd创建用户时和主目录相关的参数是
-p 设定帐号的密码
-d 指定用户的主目录
-m 自动建立用户的主目录
-M 不要自动建立用户的主目录
A，route命令用来显示目前本机路由表的内容，并且还可以针对路由表中的记录来进行相应的添加、删除或修改等操作。
B，ifconfig命令用来来检测和设置本机的网络接口。
C，ping命令用来检测两部主机之间的传输信道是否畅通，或远程主机是否正常
D,netstat命令用来查看主机的连接状态
文件描述符0：标准输入设备
文件描述符1：标准输出设备
文件描述符2：标准错误输出设备
方式一：free 直观的展示linux系统内存使用及交换区的容量大小等
方式二：top 动态实时查看系统中每一个进程的资源使用情况
方式三：cat /proc/meminfo
方式四：gnome-system-monitor 一个显示最近一段时间内的CPU、内存、交换区及网络使用情况的视图工具。
方式五：ps aux –sort -rss 各个线程的资源使用情况
方式六：vmstat -s vmstat 命令显示实时的和平均的统计，覆盖CPU、内存、I/O等内容。
终止一个前台进程用 ctrl+C；
终止一个后台进程：1、使用kill命令；2、使用fg命令将后台进程变为前台进程，然后 ctrl+C。
后台运行可以有两种方式： 1.命令前加nohup # nohup  *.sh 2.命令后加& #  *.sh &
dd 删除光标所在的那一整行
yy 复制光标所在的那一整行
p 将已复制的数据在光标的下一行粘贴
P 将已复制的数据在光标的上一行粘贴
按照进程的功能和运行的程序分类，进程可划分为两大类：
(1) 系统进程：可以执行内存资源分配和进程切换等管理工作；而且，该进程的运行不受用户的干预，即使是root用户也不能干预系统进程的运行。 
(2) 用户进程：通过执行用户程序、应用程序或内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。

针对用户进程，又可以分为交互进程、批处理进程和守护进程三类。 
(1) 交互进程：由一个shell终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。 
(2) 批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。    
(3) 守护进程：守护进程是一直运行的一种进程，经常在linux系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如httpd进程，一直处于运行状态，等待用户的访问。还有经常用的crond进程，这个进程类似与windows的计划任务，可以周期性的执行用户设定的某些任务。
1.ADM 文件是不能单独打开的。
2.ADM 文件是组策略用以描述基于注册表的策略设置在注册表中的存储位置的模板文件。
3.ADM 文件还描述了管理员在“组策略对象编辑器”管理单元中看到的用户界面。管理员使用组策略对象编辑器创建或修改组策略对象 (GPO)。
采用uEFI的计算机可以支持MBR，但是需要在BIOS中打开CSM之类的。
之后->grub->initrd就是常规操作。
但是说grub也不太合适，毕竟bootloader有很多，例如clover、rEFland之类的。
比较新的linux内核可以支持直接从内核启动，这种引导方式叫做EFISTUB
贴一段Archlinux的UEFI启动过程的wiki：
系统开机 - 上电自检（Power On Self Test 或 POST）。
UEFI 固件被加载，并由它初始化启动要用的硬件。
固件读取其引导管理器以确定从何处（比如，从哪个硬盘及分区）加载哪个 UEFI 应用。
固件按照引导管理器中的启动项目，加载UEFI 应用。
已启动的 UEFI 应用还可以启动其他应用（对应于 UEFI shell 或 rEFInd 之类的引导管理器的情况）或者启动内核及initramfs（对应于GRUB之类引导器的情况），这取决于 UEFI 应用的配置。
假设我有test1.c,test2.c两个源文件，先使用gcc -c *.c将源文件编译成目标文件，可以生成了test1.o,test2.o两个目标文件，然后，使用ar命令：ar crv libtest.a *.o将该目录下的所有目标文件打包生成了libtest.a文件。这样，你在编译的时候就可以直接使用这个静态库了。
/etc/mtab文件的作用：记载的是现在系统已经装载的文件系统，包括操作系统建立的虚拟文件等；而/etc/fstab是系统准备装载的
etc/fstab文件的作用 ：记录了计算机上硬盘分区的相关信息，启动 Linux 的时候，检查分区的 fsck 命令，和挂载分区的 mount 命令，都需要 fstab 中的信息，来正确的检查和挂载硬盘。
子网掩码255.255.255.0就代表24（二进制），一个255是11111111（8个1），那么三个255就是24。而动态地址的分配从100-200，第一个便是100，一共是101个
DNS服务器主配置文件：  /etc/named.conf
FTP服务器有两个端口，其中21端口用于连接，20端口用于传输数据 
进行FTP文件传输中，客户端首先连接到FTP服务器的21端口，进行用户的认证，认证成功后，要传输文件时，服务器会开一个端口为20来进行传输数据文件。 
也就是说，端口20才是真正传输所用到的端口，端口21只用于FTP的登陆认证。我们平常下载文件时，会遇到下载到99%时，文件不完成，不能成功的下载。其实是因为文件下载完毕后，还要在21端口再行进行用户认证，而下载文件的时间如果过长，客户机与服务器的21端口的连接会被服务器认为是超时连接而中断掉，就是这个原因。解决方法就是设置21端口的响应时间。
所谓系统调用，就是内核提供的、功能十分强大的一系列的函数。这些系统调用是在内核中实现的，再通过一定的方式把系统调用给用户，一般都通过门(gate)陷入(trap)实现。系统调用是用户程序和内核交互的接口。
文件IO中读取文件首先调用系统函数并传送文件名，选择一个路径打开文件。函数取回的顺序号就是文件句柄。
0标准输入 1标准输出 2标准错误 3标准辅助 4标准列表

ifconfig
1.作用：ifconfig用于查看和更改网络接口的地址和参数，包括IP地址、网络掩码、广播地址，使用权限是超级用户。
2.格式    ifconfig -interface [options] address
3.主要参数如下：
-interface：指定的网络接口名，如eth0和eth1。
up：激活指定的网络接口卡。
down：关闭指定的网络接口。
broadcast address：设置接口的广播地址。
pointopoint：启用点对点方式。
address：设置指定接口设备的IP地址。
netmask address：设置接口的子网掩码。

/etc/group是用户组信息文件，里面定义了用户组的ID,  /etc/passwd是用户基本信息文件，里面定义了用户的ID，用户组的ID等相关信息，所以因为两个文件中都定义了用户组的信息，所以两个文件应该都要改过来，否则会导致用户找不到所属组

从上往下查找，就像坐滑滑梯-------/
从下往上查找，就需要倒挂金钩了-------？

$#，表示参数个数
tcpdump是简单可靠网络监控的实用工具
top 显示活动进程方面的情况
netstat显示网络有关的信息，比如套接口使用情况、路由、接口、协议（TCP等）等
ifconfig是查看活动的网卡信息

BSS（Block Started by Symbol）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。特点是:可读写的，在程序执行之前BSS段会自动清0。所以，未初始的全局变量在程序执行之前已经成0了。 
数据段：数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。 
代码段：代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。 
堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减） 
栈(stack)：栈又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区
malloc是库函数，"操作系统申请内存的接口 "指的是系统调用，库函数中封装了系统调用，库函数与系统调用是两个不同的概念。所以D选项错误。
106.13.213.111   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
